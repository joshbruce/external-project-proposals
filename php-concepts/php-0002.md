Help wanted: RFC submission and implementation.

As of this writing I do not believe I have the [karma points](https://wiki.php.net/rfc/howto) (step 2) required to submit an RFC myself.

As of this writing I do not have the knowledge, practice, and practical understanding of implementing within PHP internals to implement this myself. If you're interested in (helping) implement this concept, please do reach out (help may be in the form guidance and instruction or full implementation, up to you).

(After the RFC process and clearly defining what's being done.)

**Perceived roadblocks**

None

**Known questions and concerns still outstanding:**

- How would `new stdClass()` result in `null` without developer intervention or PHP error?
- Should `empty()` be treated differently than being cast as a `bool`, and why?
  - I have a personal use case for wanting them to be potentially different, but that's only one use case.
- Would it be more universally appropriate to have a way to define an object "as empty" - does this already exist?
- ~Does the rationale section add value? (Removed for now, if you've read before and don't miss it, question answered.)~
- ~What to name the interface(s) as it (they) does (do) not fit the *-able pattern well.~
- ~The drawbacks and potential complexity (or adding bugs) in implementing the cast capability.~
- ~Whether to use magic method only, interface only, or both (as of now, we are going with both to increase the potential for future consistency based on what is in PHP 8, and RFCs under review).~
- ~Rumors of magic methods going away - not from folks in the deep end of PHP development near as I can tell.~

Please feel free to add more.

***

# Create functional interface so objects may declare emptiness and by extension truthiness

This [concept] introduces a way to represent an empty value object without using `null` by introducing a new `Emptiable` interface with `isEmpty()` method.

This [concept] has # goals:

1. provide a way to represent an instantiated, albeit "empty" and "false" object, without using `null` that is consistent with similar approaches seen in `Countable` and `Stringable`.[^1]
2. provide an `Emptiable` functional interface allowing binary result for `empty()` and cast to `bool`, and
3. ~allow `bool|Emptiable` to express `bool|object-with-isEmpty()`, and~
3. no BC breaks (no polyfill is planned at this time).

## Introduction

Goal 1: For scalar types, emptiness appears directly tied to truthiness. For compound types the behavior appears limited and inconsistent.

The following demonstrations use one scalar type (string) and one compound type (array) to illustrate the difference when it comes to objects (other scalar and compound types are in the Demonstrations section).

Scalar types and their relationship to `empty()` and `(boo)` cast:

|Type     |Value/Context    |Result from `empty()`  |Result from `(bool)` cast  |Result from conditional if ({value}) {} |
|:--------|:----------------|:---------------------:|:-------------------------:|:--------------------------------------:|
|string   |"Hello"          |`false`                |`true`                     |`true` - inside braces                  |
|integer  |>= 1             |`false`                |`true`                     |`true`                                  |
|integer  |<= -1            |`false`                |`true`                     |`true`                                  |
|float    |> 0              |`false`                |`true`                     |`true`                                  |
|float    |< 0              |`false`                |`true`                     |`true`                                  |
|string   |""               |`true`                 |`false`                    |`false` - outside braces                |
|integer  |0                |`true`                 |`false`                    |`false`                                 |
|float    |0.0              |`true`                 |`false`                    |`false`                                 |
|null     |null             |`true`                 |`false`                    |`false`                                 |

Compound types (no pseudo-types) and their relationship to `empty()` and `(bool)` cast:

|Type     |Value/Context    |Result from `empty()`  |Result from `(bool)` cast  |Result from conditional if ({value}) {} |
|:--------|:----------------|:---------------------:|:-------------------------:|:--------------------------------------:|
|array    |[1, 2, 3]        |`false`                |`true`                     |`true`                                  |
|callable |function() {}    |`false`                |`true`                     |`true`                                  |
|object   |new stdClass()   |`false`                |`true`                     |`true`                                  |
|array    |[]               |`true`                 |`false`                    |`false`                                 |

`null` and its relationship to `empty()` and `(bool)` cast:

|Type     |Value/Context    |Result from `empty()`  |Result from `(bool)` cast  |Result from conditional if ({value}) {} |
|:--------|:----------------|:---------------------:|:-------------------------:|:--------------------------------------:|
|NULL     |--               |`true`                 |`false`                    |`false`                                 |

Of the non-special and -pseudo types, only two are not able to represent an `empty` (read `false`) version of themselves: `callable` and `object`; they are always true, when set or instantiated. The alternative used is often `null`, which is a different type and always empty (no way to interact with `null` - asking a non-thing if it exists and always getting "no" in reponse), alternatively, returning an instance that resolves to empty or false would be similar to interacting with an empty array and string or integer and float with a value of absolute zero, only with access to properties and methods (consider chains and pipes).

Given `callable` returns the result of a function, which may be an object implementing `isEmpty()` it is considered beyond the scope of this [concept]. At present, in the case of `object` a developer cannot return an empty, instantiated version of their custom object (type); therefore, a developer interacting with a library or other codebase cannot be guaranteed they will receive an instance of the object; instead, they may receive `null`, which is a different type.

Consider a mixed type array:

```php
$array = [
  new stdClass(),
  [1, 2, 3],
  "",
  "Hello",
  [],
  new ClassWithIsEmptyReturningFalse()
];

$filtered = array_filter($array, function($item) { return ! empty($item) });

// output:
// [
//   [1, 2, 3],
//   "Hello",
//   {ClassWithIsEmptyReturningFalse}
// ]

// output (without isEmpty):
// [
//   {stdClass},
//   [1, 2, 3],
//   "Hello",
//   {ClassWithIsEmptyReturningFalse}
// ]
```

Without `isEmpty()`, the implementation would not be possible as is, the closure would need to be modified.

```php
$array = [
  new stdClass(),
  [1, 2, 3],
  "",
  "Hello",
  [],
  new ClassWithIsEmptyReturningFalse()
];

$filtered = array_filter($array, function($item) { 
  if (is_object($item) and (method_exists($item, "isEmpty") and $item instanceof Emptiable)) {
    return $item->isEmpty();
  }
  return ! empty($item) 
});

// output:
// [
//   [1, 2, 3],
//   "Hello",
//   {ClassWithIsEmptyReturningFalse}
// ]
```

Goal 2: To maintain consistency and feel in PHP, this [concept] follows the `Countable` interface and implementation, as such the interface will need to be part of the class declaration. 

(Unless we want this rationale to apply to instances of `stdClass()`, which would be more like `Stringable` with dynamic declaration at compile time. If that's the case, `isEmpty()` should probably be a magic method to avoid possible name collisions. While simultaneously opening the door to those using such a method to declare the interface and remove direct calls to the method.)

The interface stub.

```php
interface Emptiable
{
  public function isEmpty(): bool;
}
```

Goal 3: As this is a new language feature and requires declaring the interface explicity ~PHP guidance reserves method or function names preceded by two underscores~, there should be no backward compatibility issues or concerns. 

## Backward Incompatible Changes

No known incompatibilities.

## Proposed PHP Version(s)

PHP 8.1 or later (as I can't imagine it being approved and implemented for the PHP 8 code freeze)

## RFC Impact

No known negative impacts.

## Unaffected PHP Functionality

No known affect on current fuctionality.

## Future Scope

Not at this time.

## See also

These RFCs are identified as similar in spirit to this [concept], possibly helped by this [concept], or this [concept] is potentially helped by the result of the linked RFC.

- [PHP RFC: Pipe Operator v2](https://wiki.php.net/rfc/pipe-operator-v2)
- [PHP RFC: Userspace operator overloading](https://wiki.php.net/rfc/userspace_operator_overloading)
- [PHP RFC:__toArray()](https://wiki.php.net/rfc/to-array)
- [PHP RFC: Nullsafe operator](https://wiki.php.net/rfc/nullsafe_operator)
- (approved for PHP 8) [PHP RFC: Union Types 2.0](https://wiki.php.net/rfc/union_types_v2)
- [PHP RFC: Add Stringable interface](https://wiki.php.net/rfc/stringable)
